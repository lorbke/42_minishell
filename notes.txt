




----------requirements----------

detailed list: https://docs.google.com/spreadsheets/d/e/2PACX-1vT4i9G61JSd0ertOLZsAsqvcUH_Dag3FZ5ERm26vLdXnKcJ-NtZctL4mmMCGp1SATtZvCKPbXUsTg5G/pubhtml



----------approach-------------

- understand last two requirements' logic
- structure the requirements into a project structure oriented toward the actual bash shell
- implement the structure step by step while making sure the implemented bit works exactly like bash by testing and reading shell manual


----------logic-------------

structure flowchart: https://lucid.app/lucidspark/6b5a618b-0bb7-4dbb-bef9-ecfa5268be38/edit?invitationId=inv_e9f761d2-aae8-446b-a770-ca45b661721d#

---whats a .y file and is it sensible to use it when parsing?

---signal handler
	- where?

---environment variables
	- export?
	- passing to subshell?

---subshells
	- why?
		- parallel computation
		- isolation of effects (such as changing envs)
	- when is it created?
		- in the executor
	- how does it handle an already determined input (prompt skip)?

---Parse tree (dependency-based-parse-tree) https://en.wikipedia.org/wiki/Parse_tree
	- example in structure flowchart
	- tokens are parsed left-to-right, tokens have a precedence
	- when a token with a higher precedence than the one before appears, a rotation is performed (recursive pointer swap)
	- how are parenthesis represented in the tree?
		- everything in parenthesis is handled in a subshell, return value of subshell is represented as a token in the main tree
	- how are quotation marks represented in the tree?
		- these are already handled in the token list, everything in between quotes is a single token
	- how is precedence determined?
		- determined by the grammar
		- other parts of grammar are handled by simple if statements in the executor (e.g. &&-operator will stop execution after one element is true)
	- how is the tree structured exactly, so that the executor can execute in the correct order?
		- left-right recursion has to lead to the correct order, with special cases such as commands that are put first in the command table assembled by the executor

(---token types
	–Control operators (|, ||) 
	–Redirection operators (>, >>) 
	–Reserved words (while, if) 
	–Assignment tokens (foo=bar) 
	–Word tokens (everything else))

---WORD_DESC is a data struct used to pass information from one stage to next

---lexical analysis
	- basic unit = word
	- words are separated by metacharacters, (tab, space)
		- other special characters: double/single quotation mark, &&/||, /, pipe, >>/<</>/<, ($)?)
	- will "tokenize" these units according to grammar rules into a list structure
	- will identifiy tokens based on context and store ident in list
		- what identification categories are there? >> see bash source code repo, parser.h
		- identifiers/flags are stored as macros that represent a bit in an integer. The token list will contain an integer to represent all possible flags 
	- context-dependent analysis
		- categorizes words according to token type
	--> passes list to parser to be assembled into statements and commands
	---bash grammar
		- posix standard

---expander
	- expansion happens immediately before execution, iteratively for every single execution (because logical operands can change expansion output in between executions)
	- the word expansion loop resembles a pipeline: each iteration a possible expansion based on the flags is performed
		- this is important, since replication of bash's behaviour is the goal. The expansion therefore should happen in the same order as the original. This means that the flags also have to represent the same bits.


------debugging-------

- its sensible to replicate the bash debug behaviour
	- bash debugs using a DEBUG macro, just like pfuchs minishell does